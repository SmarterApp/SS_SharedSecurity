/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * https://bitbucket.org/sbacoss/eotds/wiki/AIR_Open_Source_License
 ******************************************************************************/
package org.opentestsystem.shared.security.integration;

import org.apache.commons.collections.CollectionUtils;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.security.domain.SbacPermission;
import org.opentestsystem.shared.security.domain.permission.PermissionResponse;
import org.opentestsystem.shared.security.domain.permission.SbacPermissionEntity;
import org.opentestsystem.shared.security.domain.permission.SbacPermissionMappingResponse;
import org.opentestsystem.shared.security.domain.permission.UserRole;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestOperations;

import javax.annotation.Resource;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Integrated implementation of the Program Management client. Only auto-wired when the
 * "permission.client.impl.integration" profile is active. Talks to a running instance of the Program Management REST
 * api.
 */
@Component
public class PermissionClient {

    private static final Logger LOGGER = LoggerFactory.getLogger(PermissionClient.class);

    private static final String GET_ROLES_ENDPOINT = "/role";
    private static final String GET_SINGLE_ROLE_ENDPOINT = "/role?role=";
    private static final String GET_PERMISSIONS_ENDPOINT = "/permission";

    /**
     * RestTemplate used to talk to the REST API
     */
    @Resource(name = "permissionRestTemplate")
    protected RestOperations restTemplate;

    /**
     * Base URI to use to talk to REST API
     */
    // Note: The colon is important to default to blank here.
    // http://www.javacodegeeks.com/2013/01/spring-property-placeholder-configurer-a-few-not-so-obvious-options.html
    @Value(value = "${permission.uri:}")
    private String baseUri;

    // @Cacheable(value = "PermissionClient.getPermissionByComponentName", key = "#componentName", unless =
    // "#result == null")
    public SbacPermissionMappingResponse getPermissionByComponentName(final String componentName) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("attempting to call " + baseUri + "/role?component={component} with " + componentName);
        }
        try {
            return restTemplate.getForObject(baseUri + "/role?component={component}",
                    SbacPermissionMappingResponse.class, componentName);
        } catch (Exception e) {
            throw new LocalizedException("there was an issue retrieving permissions for component" + componentName, e);
        }
    }

    /**
     * Get all available roles.
     *
     * @return List<UserRole> roles
     */
    public List<UserRole> getRoles() {
        try {
            String url = baseUri.concat(GET_ROLES_ENDPOINT);
            ParameterizedTypeReference<PermissionResponse<UserRole>> typeRef = new ParameterizedTypeReference<PermissionResponse<UserRole>>() {};
            ResponseEntity<PermissionResponse<UserRole>> response = restTemplate.exchange(url, HttpMethod.GET, null, typeRef);
            PermissionResponse<UserRole> permissionResponse = response.getBody();
            return permissionResponse.getValue();
        } catch (HttpClientErrorException hce) {
            return null;
        }
    }

    /**
     * Get all available roles as map with role name as key.
     *
     * @return Map<String, UserRole> roleMap
     */
    public Map<String, UserRole> getRolesMap() {
        Map<String, UserRole> roleMap = new HashMap<>();
        for (UserRole userRole : getRoles()) {
            roleMap.put(userRole.getRole(), userRole);
        }
        return roleMap;
    }

    /**
     * Get a role by name.
     *
     * @param rolename
     *            role name
     * @return UserRole role
     */
    // @Cacheable(value = "PermissionClient.getRole", key = "#rolename", unless = "#result == null")
    public UserRole getRole(final String rolename) {
        try {
            UserRole role = null;
            String url = baseUri.concat(GET_SINGLE_ROLE_ENDPOINT).concat(rolename);
            ParameterizedTypeReference<PermissionResponse<UserRole>> typeRef = new ParameterizedTypeReference<PermissionResponse<UserRole>>() {};
            ResponseEntity<PermissionResponse<UserRole>> response = restTemplate.exchange(url, HttpMethod.GET, null,
                    typeRef);
            PermissionResponse<UserRole> permissionResponse = response.getBody();
            if (CollectionUtils.isNotEmpty(permissionResponse.getValue())) {
                role = permissionResponse.getValue().get(0);
            }
            return role;
        } catch (HttpClientErrorException hce) {
            return null;
        }
    }

    /**
     * Get all available permissions.
     *
     * @return List<String> permissions
     */
    // @Cacheable(value = "PermissionClient.getPermissions", unless = "#result == null || #result.size() == 0")
    public List<SbacPermission> getPermissions() {
        try {
            String url = baseUri.concat(GET_PERMISSIONS_ENDPOINT);
            ParameterizedTypeReference<PermissionResponse<SbacPermission>> typeRef = new ParameterizedTypeReference<PermissionResponse<SbacPermission>>() {};
            ResponseEntity<PermissionResponse<SbacPermission>> response = restTemplate.exchange(url, HttpMethod.GET,
                    null, typeRef);
            PermissionResponse<SbacPermission> permissionResponse = response.getBody();
            return permissionResponse.getValue();
        } catch (HttpClientErrorException hce) {
            return null;
        }
    }

    /**
     * Check if role exists in the list of available roles.
     *
     * @param rolename
     *            role name to check for existence
     * @return true if exists else false
     */
    @Cacheable(value = "PermissionClient.hasRole", key = "#rolename", unless = "#result == false")
    public boolean hasRole(final String rolename) {
        return getRole(rolename) != null;
    }

    /**
     * Check if role exists and in one of the allowable entities.
     *
     * @param rolename
     *            role name to check for existence
     * @param level
     *            allowable entity
     * @return true if exists else false
     */
    @Cacheable(value = "PermissionClient.hasRoleAndLevel", key = "#rolename + #level", unless = "#result == false")
    public boolean hasRoleAndLevel(final String rolename, final String level) {
        UserRole role = getRole(rolename);
        if (role != null) {
            for (SbacPermissionEntity entity : role.getAllowableEntities()) {
                if (entity.getEntity().equals(level)) {
                    return true;
                }
            }
        }
        return false;
    }

    public void setRestTemplate(final RestOperations inRestTemplate) {
        restTemplate = inRestTemplate;
    }

    public RestOperations getRestTemplate() {
        return restTemplate;
    }

    public void setBaseUri(final String inBaseUri) {
        baseUri = inBaseUri;
    }

    public String getBaseUri() {
        return baseUri;
    }
}
