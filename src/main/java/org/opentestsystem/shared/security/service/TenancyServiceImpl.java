/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *   
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.shared.security.service;

import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.shared.progman.client.ProgManClient;
import org.opentestsystem.shared.progman.client.domain.Tenant;
import org.opentestsystem.shared.progman.client.domain.TenantSubscription;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.security.domain.SbacEntity;
import org.opentestsystem.shared.security.domain.SbacRole;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

@Service
public class TenancyServiceImpl implements TenancyService {

    @Autowired(required = false)
    private transient ProgManClient progManClient;

    @Value("${component.name:}")
    private String componentName;

    @Override
    public Map<String, Object> getSkinnableAssets(final SbacRole sbacRole) {
        final Map<String, Object> assets = this.progManClient.getCustomAssets(this.componentName, getTenancyParams(sbacRole));
        return assets;
    }

    @Override
    public boolean hasGoodStandingTenancyForComponent(final Tenant tenant, final String componentName) {
        boolean valid = false;
        for (final TenantSubscription subscription : tenant.getTenantSubscriptions()) {
            if (StringUtils.equals(subscription.getComponent().getName(), componentName)) {
                if (subscription.getEffectiveDate().isBeforeNow() && subscription.isInGoodStanding()) {
                    if (subscription.getExpirationDate() == null || subscription.getExpirationDate().isAfterNow()) {
                        valid = true;
                        break;
                    }
                }
            }
        }
        return valid;
    }

    @Override
    public List<Tenant> getApplicableTenants(final Set<SbacEntity> entities) {
        final List<Tenant> ret = Lists.newArrayList();
        if (entities != null) {
            for (final SbacEntity sbacEntity : entities) {
                if (StringUtils.isNotBlank(sbacEntity.getEntityName())) {
                    ret.addAll(callForTenancy(sbacEntity.getEntityType(), sbacEntity.getEntityId()));
                }
            }
        }
        return ret;
    }

    private Map<TenantType, String> getTenancyParams(final SbacRole sbacRole) {
        final Map<TenantType, String> params = Maps.newHashMap();
        for (final TenantType type : TenantType.values()) {
            final String eName = sbacRole.getEntityByType(type) == null ? null : sbacRole.getEntityByType(type).getEntityId();
            if (eName != null) {
                params.put(type, eName);
            }
        }
        return params;
    }

    @Cacheable(value = "applicableTenantsCache", key = "#tenantType + #entityId")
    public List<Tenant> callForTenancy(final TenantType tenantType, final String entityId) {
        final List<Tenant> ret = Lists.newArrayList();
        final Set<Tenant> tenantChainSet = this.progManClient.getTenantChain(ImmutableMap.of(tenantType, entityId)).getTenants();
        if (!CollectionUtils.isEmpty(tenantChainSet)) {
            for (final Tenant tenant : tenantChainSet) {
                if (hasGoodStandingTenancyForComponent(tenant, this.componentName)) {
                    ret.add(tenant);
                }
            }
        }
        return ret;
    }
}
