/*******************************************************************************
 * Educational Online Test Delivery System 
 * Copyright (c) 2014 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0 
 * See accompanying file AIR-License-1_0.txt or at
 * https://bitbucket.org/sbacoss/eotds/wiki/AIR_Open_Source_License
 ******************************************************************************/
package org.opentestsystem.shared.security.service;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.shared.progman.client.ProgManClient;
import org.opentestsystem.shared.progman.client.domain.Tenant;
import org.opentestsystem.shared.progman.client.domain.TenantChain;
import org.opentestsystem.shared.progman.client.domain.TenantSubscription;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.security.domain.SbacEntity;
import org.opentestsystem.shared.security.domain.SbacRole;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

@Service
public class TenancyServiceImpl implements TenancyService {

    @Autowired(required = false)
    private transient ProgManClient progManClient;

    @Value("${component.name:}")
    private String componentName;

    @Override
    public Map<String, Object> getSkinnableAssets(final SbacRole sbacRole) {
        final Map<String, Object> assets = this.progManClient.getCustomAssets(this.componentName, getTenancyParams(sbacRole));
        return assets;
    }

    @Override
    public boolean hasGoodStandingTenancyForComponent(final Tenant tenant, final String componentName) {
        boolean valid = false;
        for (final TenantSubscription subscription : tenant.getTenantSubscriptions()) {
            if (StringUtils.equals(subscription.getComponent().getName(), componentName)) {
                if (subscription.getEffectiveDate().isBeforeNow() && subscription.isInGoodStanding()) {
                    if (subscription.getExpirationDate() == null || subscription.getExpirationDate().isAfterNow()) {
                        valid = true;
                        break;
                    }
                }
            }
        }
        return valid;
    }

    @Override
    public List<Tenant> getApplicableTenants(final Set<SbacEntity> entities) {
        final List<Tenant> ret = Lists.newLinkedList();
        if (entities != null) {
            Map<TenantType, String> entityMap = new HashMap<TenantType, String>();
            for (final SbacEntity sbacEntity : entities) {
                //filters out role entities that might not be populated
                if (StringUtils.isNotBlank(sbacEntity.getEntityId())) {
                    entityMap.put(sbacEntity.getEntityType(), sbacEntity.getEntityId());
                }
            }
            ret.addAll(callForTenancy(entityMap));
        }
        return ret;
    }

    private Map<TenantType, String> getTenancyParams(final SbacRole sbacRole) {
        final Map<TenantType, String> params = Maps.newHashMap();
        for (final TenantType type : TenantType.values()) {
            final String eName = sbacRole.getEntityByType(type) == null ? null : sbacRole.getEntityByType(type).getEntityId();
            if (eName != null) {
                params.put(type, eName);
            }
        }
        return params;
    }

    public List<Tenant> callForTenancy(final Map<TenantType, String> entities) {
        final List<Tenant> ret = Lists.newLinkedList();


        Set<Tenant> tenantChainSet = new HashSet<Tenant>();
        final TenantChain tenChain = this.progManClient.getTenantChain(entities);
        if (tenChain != null) {
            tenantChainSet = tenChain.getTenants();
        }
        //remove any tenants that are not applicable for the given component (not a valid subscription)
        if (!CollectionUtils.isEmpty(tenantChainSet)) {
            for (final Tenant tenant : tenantChainSet) {
                if (hasGoodStandingTenancyForComponent(tenant, this.componentName)) {
                    ret.add(tenant);
                }
            }
        }
        return ret;
    }
}
